\section{ Quantum algorithms}

Quantum algorithms are the algortihms specially designed for quantum computers. A unique property of a quantum computer is  able to perform  operations not on a single state but on   a superposition of states, so that certain classical algorithms can be amortized. The most famous examples are Shor's algorithm for factorization~\cite{DBLP:conf/focs/Shor94}
and its derivative for discrete logarithm search, as well as the Grover search algorithm~\cite{DBLP:conf/stoc/Grover96}. The latter is our main interest as we have excluded factoring- and DLP-based schemes from consideration.

\subsection{Grover's algorithm}

The Grover algorithm was originally formulated as a database search, however, it can be equivalently written as a preimage search algorithm for some hard-to-invert function.  Concretely, given $O\in Z_N$ (or any other domain efficiently mappable to $Z_N$) and function $H$, Grover algorithm finds $I$ such that $H(I)=O$ in time equivalent to $\sqrt{N}$ calls to $H$ on a quantum computer. Note that the algorithm is inherently sequential and so far no one knows how to parallelize it so that the computing time can be reduced. The probability to find the preimage in $t$ time grows as $t^2/N$~\cite{DBLP:journals/sigact/BrassardHT97}.

\subsubsection{Single-target Grover's}

Grover's algorithm makes a particular sequence of operations multiple times. At a high-level, after each iteration the probability amplitude of the marked index state is increased. Once enough iterations are performed, this amplitude is high enough that when a measurement is performed, with high probability the resulting index corresponds to the special marked state. Each iteration is made of 2 simple operations. The following description assumes that we are using Grover's algorithm to perform unstructured search on a boolean function $f: \{0, 1\}^n \rightarrow \{0, 1\}$ where there is only one unique element $x^\prime$ such that $f(x^\prime) = 1$ and $N = 2^n$. The input to Grover's algorithm is an equal superposition of all inputs:

$$ \phi_0 = \frac{1}{\sqrt{N}}\sum_{x=0}^{N-1} \ket{x} $$

The 2 operations performed at each iteration of Grover's algorithm are as follows:

\begin{itemize}
    \item \textbf{Amplitude flip} $\ket{x^\prime} \rightarrow -\ket{x^\prime}$: The amplitude of the unique element $x^\prime$ is negated. This operation is implemented using the following gate logic:
    
    $$ (-1)^{f(x)}\ket{x}=\left\{\begin{array}{ll}
\ket{x} & \text { if } f(x)=0 \\
-\ket{x} & \text { if } f(x)=1
\end{array}\right.  $$
    
    Post this operation, the state of the input qubits is:
    
    $$ -\frac{1}{\sqrt{N}}\ket{x^\prime} + \sum_{x \neq x^\prime} \frac{1}{\sqrt{N}}\ket{x} $$
    
    \item \textbf{Diffusion operator}: The goal of the diffusion operator is to increase the amplitude of $x^\prime$. The diffusion operator flips the amplitude of each $x \in \{0, 1\}^n$ around the average amplitude $\mu = \frac{1}{N}\sum_{x} A_x$ where $A_x$ represents the amplitude of $x$. This operation is implemented using the following gate logic:
    
    $$ \sum_{x \in\{0,1\}} \alpha_{x} \ket{x} \mapsto \sum_{x \in\{0,1\}^{n}}\left(2 \mu-A_{x}\right) \ket{x} $$
    
    The mean amplitude before the diffusion operator is roughly $\frac{1}{\sqrt{N}}$. Therefore, after the diffusion operator all entries remain roughly the same as they go from, $\frac{1}{\sqrt{N}}$ to $\frac{2}{\sqrt{N}} - \frac{1}{\sqrt{N}}$. However, the amplitude of $x^\prime$ , $A_{x^\prime}$, goes from $-\frac{1}{\sqrt{N}}$ to $\frac{3}{\sqrt{N}}$.
    
\end{itemize}

The above two operations are then repeatedly applied, increasing the amplitude of $x^\prime$ after each round by $\frac{2}{\sqrt{N}}$. After $O(\sqrt{N})$ rounds, the amplitude of $x^\prime$ is up to a desirable constant and at this point a measurement is performed which collapses the state to $x^\prime$ with constant probability.

\subsubsection{Multi-target Grover's}


For us the main interest is the multi-target version of the Grover algorithm, which we hope to use in the pre-computation attacks. The same algorithm works in the multi-target case but now instead of requiring $O(\sqrt{N})$ iterations, the number of iterations required is $O(\sqrt{\frac{N}{k}})$ as there are $k$ targets whose amplitude gets amplified after each iteration. %\textbf{\textit{(Should we consider the case when $k$ is unknown?)}} 
Hence, the multi-target Grover's finds a pre-image  to one of $k$ targets in time $\sqrt{N/k}$. The probability to find the pre-image in $t$ time grows as 
\begin{equation}
    \label{eq:mt-grover}
    f_{MG}(k,t,N) = kt^2/N
\end{equation}according to \cite{Brassard_2002}.

\subsubsection{Quantum Parallelism}

Achieving speed-ups via parallelism is an important line of work for most search algorithms. However, in the case of Grover's algorithm, the work of Zalka~\cite{Zalka_1999} proves that quantum searching can not be parallelized better than the naive case. The naive case assigns different parts of the search space to separate quantum computers. And hence, you get a linear improvement in search time with multiple quantum computers corresponding to increased computational cost. 

\subsection{Attacks based on Grover's}

\subsubsection{Grover Attacks 1 and 2}

We can apply Grover algorithm to our precomputation attacks from \cref{sec:precomp}. 
The first two attacks work as follows:
\begin{enumerate}
    \item Apply $F^{-1}$ (i.e. invert $F$) to  $M/\gamma$ elements of  $\mathcal{W}$  and create a proof for every inversion.
    \item Store results as $\overline{\mathcal{W}}=\{(I,O,\pi)\}$.
    \item When $\phi$ is known, check (using Grover) if there is $I$ such that  $(I,*,*)\in\overline{\mathcal{W}}$ and $\phi(I)=true$. If found then retrieve $(O,\pi)$ from $\overline{\mathcal{W}}$.
\end{enumerate}
The improvement comes in the setting when finding the right $I$ is not easy i.e. when we have to check each $\phi(I)=true$ individually. We run Grover algorithm on the set $\overline{\mathcal{W}}$ of targets in the Computation phase, and in order to increase the attack probability we run several (denoted by $G$) copies of Grover in parallel. Let us assume that a call to $\phi$ costs as much as a call to $f$. Then if each Grover is run for $\beta D$, then the chance to match any element of   $\overline{\mathcal{W}}$ can be derived from \eqref{eq:mt-grover} as 
\begin{equation}\label{eq:pmg}
    P_{MG}(\beta, D,N) = \frac{\beta^2 G D^2M}{\gamma N}
\end{equation}
so that the VDF protocol is
$$
\left(\frac{\beta^2 G D^2M}{\gamma N},\beta,M\right)\text{-quantum-sequential}
$$

Example 3: suppose   $M=2^{64}$, $D=2^{40}$, $N=2^{192}$, $G=2^{40}$, $\gamma=1/64$. Then an adversary who precomputes an  equivalent of $2^{64}$ VDF forward precomputations, can compute the $F$ output in  $1/2$ time using $2^{40}$ instances of Grover algorithm with probability $1/4$.




\subsubsection{Attacks that do not work}

Interestingly, Grover algorithm does not  seem  to improve if we switch from attacks 1-2 to   the chain-based approach (\cref{sec:att3}). The reason is that the   latter requires to compute several iterations of $f$ which can not be iterated in Grover. Thus we conclude that \eqref{eq:pmg} is the best we can hope with Grover.

For the same reason we can not effectively run a quantum meet-in-the-middle attack~\cite{DBLP:journals/sigact/BrassardHT97} on $F$ by splitting in two parts, as Grover would need to compute many iterations of $F$ sequentially.

We conclude that the security level of invertible VDFs against quantum adversaries is given by the formula
 \begin{equation}\label{eq:level2}
     \text{Security level (VDF) }\approx {\frac{\sqrt{N}}{D}} \end{equation}
which is only by the factor of $\sqrt{D}$ lower than the classical one \eqref{eq:level}.


\subsection{Practicality of Quantum Search}

Grover's search is usually discussed for some oracle function $f(\cdot)$. However, several practical issues need to be considered when a specific construction of $f(\cdot)$ is being considered. The work of Viamontes, Markov and Hayes~\cite{practicalityGrover05} focuses on these issues.  The first issue is that in order to query $f(\cdot)$ in superposition, we need a quantum hardware implementation of  $f(\cdot)$. While a quantum circuit is usually similar in size to its classical counterpart, if the the circuit's maximum depth exceeds $\sqrt{N}$ then the evaluation of  $f(\cdot)$ is the more cost consuming part of searching a size $N$ database. This would diminish the quantum speedup by a considerable amount.


\subsection{Quantum Grobner}

We note that quite little is known about the quantum complexity of Groebner basis algorithms nor of the equation solving. There exist several results showing that Gaussian elimination of sparse matrices can be sped up greatly on a quantum computer\url{https://arxiv.org/abs/0811.3171}, which in turns would shorten the elimination step in the Groebner basis algorithms. However, it is the subject of the future research if an algorithm like F4 or F5~\cite{faugere2002new} can be improved as a whole. We expect that if it can be done, running a quantum algorithm every few steps would induce high latency, and the high value of $D$ would rule out such strategies. To the best of our knowledge there is no quantum improvement to solving univariate equations either.
 
%\section{Quantum Circuits for VDF candidates}
 